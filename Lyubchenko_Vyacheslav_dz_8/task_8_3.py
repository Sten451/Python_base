"""
3. Написать декоратор для логирования типов позиционных аргументов
функции, например:
def type_logger...
    ...
@type_logger
def calc_cube(x):
   return x ** 3
>>> a = calc_cube(5)
5: <class 'int'>
Примечание: если аргументов несколько - выводить данные о каждом через запятую; да
можете ли вы вывести тип значения функции? да
Сможете ли решить задачу для именованных аргументов? да
Сможете ли вы замаскировать работу декоратора? пока ХЗ
Сможете ли вывести имя функции, например, в виде:
>>> a = calc_cube(5)
calc_cube(5: <class 'int'>)
"""
# Итак есть простейшая функция нахождение суммы чисел, однако в ней
# если хоть один аргумент не валиден, суммирование не происходит
# обертка будет проверять типы и суммировать возможное, а
# и еще решать условия задачи)))

from functools import wraps


def type_logger(func):
    # Проверяем валидность
    # Так и не понял этого достаточно или нет (ниже стр. 30).
    @wraps(func)
    def wrapped(*args, **kwargs):
        s = []
        # Если есть поименнованные получим их значения и запихнем в аргс,
        # сами ключи в данной функции нам не нужны
        if len(kwargs):
            # Не забываем перевести в список
            args = list(args)
            for i in kwargs:
                args.append(kwargs.get(i))
        if len(args):
            for i in args:
                print(func.__name__, "(", i, ":", type(i), "), ", end='')
                if isinstance(i, int) or isinstance(i, float):
                    s.append(i)
            print("")
        if len(s):
            return sum(s), type(sum(s))
        else:
            return None
    return wrapped


#@type_logger
# Функция сумма аргументов
def calc_sum(*args, **kwargs):
    try:
        return sum(args)
    except TypeError:
        # Здесь нет смысла что-то писать, т.к. в стр. 77 все равно будет сообщено
        # об ошибке, иначе задублируется.
        pass
        #print("Проблемы с типами переданных значений")
    # Вот здесь непонятно, какой смысл здесь в Return, он же не работает,
    # Значение возвращается из обертки же...
    # может он нужен если надо будет убрать декоратор... (мысли вслух)
    # только тогда всё рухнет, поскольку типы данных разные; воткнем исключения.


# Для проверки передаем ей некоторые типы, в том числе поименнованные
d = calc_sum(5, 34, 4.05, "345", [456], a="89", b=78)
# Для проверки
#d = calc_sum(b=4, f=6, "fsdf", "dsfdsf")
if isinstance(d, tuple):
    print("Сумма: ", d[0], "Тип возвращаемого значения: ", d[1])
else:
    print("Проблемы с типами данных.")

