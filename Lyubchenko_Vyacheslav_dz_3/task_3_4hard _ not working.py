"""3. Написать функцию thesaurus(), принимающую в качестве аргументов имена сотрудников и возвращающую словарь,
в котором ключи — первые буквы имен, а значения — списки, содержащие имена, начинающиеся с соответствующей буквы.
Например: >>> thesaurus("Иван", "Мария", "Петр", "Илья")
{
    "И": ["Иван", "Илья"],
    "М": ["Мария"], "П": ["Петр"]
}
Замечание: Заранее неизвестно сколько фамилий передадут в функцию thesaurus
Подумайте: полезен ли будет вам оператор распаковки? Сможете ли вы вернуть отсортированный по ключам словарь?

4. * (вместо задачи 3) Написать функцию thesaurus_adv(), принимающую в качестве аргументов строки
в формате «Имя Фамилия» и возвращающую словарь, в котором ключи — первые буквы фамилий, а значения — словари,
реализованные по схеме предыдущего задания и содержащие записи, в которых фамилия начинается с соответствующей буквы.
Например: >>> thesaurus_adv("Иван Сергеев", "Алла Сидорова", "Инна Серова",
           "Петр Алексеев", "Илья Иванов", "Анна Савельева", "Василий Суриков")
{
   'А':{
          'П': ['Петр Алексеев']},
   'И': {
          'И': ['Илья Иванов']},
   'С': {
          'А': ['Алла Сидорова', 'Анна Савельева'],
          'В': ['Василий Суриков'],
          'И': ['Иван Сергеев', 'Инна Серова']}}
Сможете ли вы вернуть отсортированный по ключам словарь? """
import copy

def thesaurus_adv(*args):

    fio_0 = {}
    fio = {}
    fio2 = {}
    key_list = []
    name_key = []
    args = list(args)
    #Сразу сортируем, интуитивно понятно как, но увы не до конца как нужно.
    args.sort(key=lambda name: name.split(" ")[-1].lower())

    for i in args:

        # Получаем значение строки и переводим сразу его в список
        name_key.append(" ".join(i.split()))
        # Получаем значение первого ключа
        key_l1 = (i.split()[-1])[0]
        # Получаем значение второго ключа
        key_l2 = (i.split()[0])[0]


        # Если первый ключ уже имеется:
        if key_l1 in fio2:
            #Проверяем на идентичность второго ключа из списка ключей
            if key_l2 in key_list:
                k = " ".join(fio2.get(key_l1).get(key_l2))
                name_key.append(k)
                fio_0[key_l2] = name_key
                # Это работает почему-то, но почему непонятно, разве ключ при присвоении значения создается...
                fio2[key_l1][key_l2] = name_key

            else:
                #Второй ключ не найден, но первый такой же
                fio2[key_l1][key_l2] = name_key
        else:
            fio_0[key_l2] = name_key
            fio[key_l1] = fio_0

        fio2.update(fio)
        fio2 = copy.deepcopy(fio2)
        # Добавляем в список созданных ключей второго уровня
        key_list.append(key_l2)
        #Производим очистку
        fio_0.clear()
        fio.clear()
        name_key.clear()


   # for i in sorted(fio2.items(), key=lambda para: (para[1], para[0])):
    #    print(i)

    return (fio2)


#fio2 = thesaurus_adv("Петр Алексеев", "Илья Иванов", "Алла Сидорова", "Анна Савельева", "Василий Суриков", "Иван Сергеев", "Инна Серова")
#print(fio2)
fio2 = thesaurus_adv("Иван Сергеев", "Алла Сидорова", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева", "Василий Суриков")
print(fio2)

